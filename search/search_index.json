{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Django To Rest is small tool that helps to expose REST api(s) for django models with minimum effort. This utility is for one who uses Django REST Framework for writing REST APIs. The tool enables you to focus only on the code needed explicitly. The tool handles all boilerplate. Some of the features are: Just add a decorator at top of a model and REST api(s) are created. That's the work!!! Options like filtering and ordering are avilable by default for model fields Easy customisations via the decorator itself Summary: Less time??? Just install the tool and use the decorator. Done!!! Documentation: https://anp-scp.github.io/django-to-rest Source Code: https://github.com/anp-scp/django-to-rest Requirements \u00b6 Django to Rest need following requirements : Python 3.8+ Django 4.0.5 djangorestframework 3.13.1 django-filter 22.1 Installation \u00b6 django-to-rest is published as a package and can be installed using pip. Install with (consider creating a virtual environment): python3 -m pip install django-to-rest Example \u00b6 Let us have a look on an example of how the tool can be used to expose REST API. Let us assume that the following are the requirements: A polls app having certain questions and each question have some choices. All CRUD URLs for question and choice objects. We need an URL which simply increments a counter Make sure that djangorestframework is installed and included in INSTALLED_APPS in settings.py as shown below: settings.py 1 2 3 4 5 6 ... INSTALLED_APPS = [ 'rest_framework' , ... ] ... Now create two models as shown below: models.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from django.db import models from django.utils import timezone from django.contrib import admin from to_rest.decorators import restifyModel # (1) # Create your models here. @restifyModel # (2) class Question ( models . Model ): question_text = models . CharField ( max_length = 200 ) pub_date = models . DateTimeField ( 'date published' ) def __str__ ( self ): return self . question_text @restifyModel # (3) class Choice ( models . Model ): question = models . ForeignKey ( Question , on_delete = models . CASCADE , related_name = 'choices' ) choice_text = models . CharField ( max_length = 200 ) votes = models . IntegerField ( default = 0 ) def __str__ ( self ): return self . choice_text Import the decorator from the library Note the way decorator is used Note the way decorator is used Note the use of the decorators. We just need to use the decorator and all the views and serializers would be created during startup. But apart from that, we need one more line to add in urls.py of the project (not any app) as shown below: urls.py 1 2 3 4 5 6 7 8 from django.urls import path from to_rest import utils from django.http import JsonResponse urlpatterns = [ ... ] urlpatterns . extend ( utils . restifyApp ( 'rest/v1' )) # (1) call this method to add the urls in url patterns. Here the parameter 'rest/v1' is the prefix to be used in the url. That's all. All the above configurations will create the CRUD APIs for the classes that we marked using the decorator. For the 3rd requirement we can simply write a method the way we write in Django or Django REST Framework . We add the following lines in urls.py : count = 0 def counter ( request ) : global count if request . method == 'GET' : count += 1 return JsonResponse ({ 'count' : count }) urlpatterns . append ( path ( 'count/' , counter )) Now start the server. We add some data and check the dev url http://127.0.0.1:8000/ . Below is an example with httpie: $ http -b --unsorted http://127.0.0.1:8000/ { \"rest/v1/polls/question\": \"http://127.0.0.1:8000/rest/v1/polls/question\", \"rest/v1/polls/choice\": \"http://127.0.0.1:8000/rest/v1/polls/choice\" } $ http -b --unsorted http://127.0.0.1:8000/rest/v1/polls/question [ { \"id\": 1, \"question_text\": \"How is the traffic?\", \"pub_date\": \"2022-07-08T10:02:16.290713Z\", \"choices\": \"/rest/v1/polls/question/1/choices\" }, { \"id\": 2, \"question_text\": \"What's up?\", \"pub_date\": \"2022-07-08T10:03:15.816192Z\", \"choices\": \"/rest/v1/polls/question/2/choices\" } ] $ http -b --unsorted http://127.0.0.1:8000/rest/v1/polls/question/1/choices [ { \"id\": 1, \"choice_text\": \"Highly Conjested\", \"votes\": 0, \"question\": 1 }, { \"id\": 2, \"choice_text\": \"Clear for miles\", \"votes\": 0, \"question\": 1 } ] $ http -b --unsorted http://127.0.0.1:8000/count/ { \"count\": 1 } $ http -b --unsorted http://127.0.0.1:8000/count/ { \"count\": 2 } $ http -b --unsorted http://127.0.0.1:8000/count/ { \"count\": 3 } Here, we wrote extra code only for the /count/ URL and other CRUD URLs where created by the utility. Quickstart \u00b6 The quick start guide is a short tutorial which is the fastest way to get everything setup and get an overview of the tool. Contributing \u00b6 Check the contribution guidelines to know about how to contribute to the project.","title":"Overview"},{"location":"#requirements","text":"Django to Rest need following requirements : Python 3.8+ Django 4.0.5 djangorestframework 3.13.1 django-filter 22.1","title":"Requirements"},{"location":"#installation","text":"django-to-rest is published as a package and can be installed using pip. Install with (consider creating a virtual environment): python3 -m pip install django-to-rest","title":"Installation"},{"location":"#example","text":"Let us have a look on an example of how the tool can be used to expose REST API. Let us assume that the following are the requirements: A polls app having certain questions and each question have some choices. All CRUD URLs for question and choice objects. We need an URL which simply increments a counter Make sure that djangorestframework is installed and included in INSTALLED_APPS in settings.py as shown below: settings.py 1 2 3 4 5 6 ... INSTALLED_APPS = [ 'rest_framework' , ... ] ... Now create two models as shown below: models.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from django.db import models from django.utils import timezone from django.contrib import admin from to_rest.decorators import restifyModel # (1) # Create your models here. @restifyModel # (2) class Question ( models . Model ): question_text = models . CharField ( max_length = 200 ) pub_date = models . DateTimeField ( 'date published' ) def __str__ ( self ): return self . question_text @restifyModel # (3) class Choice ( models . Model ): question = models . ForeignKey ( Question , on_delete = models . CASCADE , related_name = 'choices' ) choice_text = models . CharField ( max_length = 200 ) votes = models . IntegerField ( default = 0 ) def __str__ ( self ): return self . choice_text Import the decorator from the library Note the way decorator is used Note the way decorator is used Note the use of the decorators. We just need to use the decorator and all the views and serializers would be created during startup. But apart from that, we need one more line to add in urls.py of the project (not any app) as shown below: urls.py 1 2 3 4 5 6 7 8 from django.urls import path from to_rest import utils from django.http import JsonResponse urlpatterns = [ ... ] urlpatterns . extend ( utils . restifyApp ( 'rest/v1' )) # (1) call this method to add the urls in url patterns. Here the parameter 'rest/v1' is the prefix to be used in the url. That's all. All the above configurations will create the CRUD APIs for the classes that we marked using the decorator. For the 3rd requirement we can simply write a method the way we write in Django or Django REST Framework . We add the following lines in urls.py : count = 0 def counter ( request ) : global count if request . method == 'GET' : count += 1 return JsonResponse ({ 'count' : count }) urlpatterns . append ( path ( 'count/' , counter )) Now start the server. We add some data and check the dev url http://127.0.0.1:8000/ . Below is an example with httpie: $ http -b --unsorted http://127.0.0.1:8000/ { \"rest/v1/polls/question\": \"http://127.0.0.1:8000/rest/v1/polls/question\", \"rest/v1/polls/choice\": \"http://127.0.0.1:8000/rest/v1/polls/choice\" } $ http -b --unsorted http://127.0.0.1:8000/rest/v1/polls/question [ { \"id\": 1, \"question_text\": \"How is the traffic?\", \"pub_date\": \"2022-07-08T10:02:16.290713Z\", \"choices\": \"/rest/v1/polls/question/1/choices\" }, { \"id\": 2, \"question_text\": \"What's up?\", \"pub_date\": \"2022-07-08T10:03:15.816192Z\", \"choices\": \"/rest/v1/polls/question/2/choices\" } ] $ http -b --unsorted http://127.0.0.1:8000/rest/v1/polls/question/1/choices [ { \"id\": 1, \"choice_text\": \"Highly Conjested\", \"votes\": 0, \"question\": 1 }, { \"id\": 2, \"choice_text\": \"Clear for miles\", \"votes\": 0, \"question\": 1 } ] $ http -b --unsorted http://127.0.0.1:8000/count/ { \"count\": 1 } $ http -b --unsorted http://127.0.0.1:8000/count/ { \"count\": 2 } $ http -b --unsorted http://127.0.0.1:8000/count/ { \"count\": 3 } Here, we wrote extra code only for the /count/ URL and other CRUD URLs where created by the utility.","title":"Example"},{"location":"#quickstart","text":"The quick start guide is a short tutorial which is the fastest way to get everything setup and get an overview of the tool.","title":"Quickstart"},{"location":"#contributing","text":"Check the contribution guidelines to know about how to contribute to the project.","title":"Contributing"},{"location":"quickstart/","text":"Setup \u00b6 Let us start fresh. Ensure that Python 3.8.x is already installed. It is always better to use virtual environment to isolate your work with other stuffs. Let us create and activate a virtual env inside the directory quickstart : # Create a virtual environment $ pwd /.../quickstart $ python3 -m venv qs $ source qs/bin/activate Installation \u00b6 python3 -m pip install django-to-rest Creation of a django project and app \u00b6 # Create a django project $ pwd /.../quickstart $ (qs) django-admin startproject mysite $ (qs) cd mysite # create an app in the project $ pwd /.../quickstart/mysite $ (qs) python3 manage.py startapp polls $ (qs) python3 manage.py migrate Creation of models \u00b6 Now, let us create some models for our polls app. We will create one model named Question and another named Choice (This is quite similar to the tutoraial available at django documentation). Here, There will be one-to-many relationship from Question to Choice . /.../quickstart/mysite/polls/models.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from django.db import models from django.utils import timezone class Question ( models . Model ): question_text = models . CharField ( max_length = 200 ) pub_date = models . DateTimeField ( 'date published' ) def __str__ ( self ): return self . question_text class Choice ( models . Model ): question = models . ForeignKey ( Question , on_delete = models . CASCADE , related_name = 'choices' ) choice_text = models . CharField ( max_length = 200 ) votes = models . IntegerField ( default = 0 ) def __str__ ( self ): return self . choice_text Activating the app \u00b6 Now, add the polls app to INSTALLED_APPS in settings.py . Also add rest_framework to it as djang-to-rest uses djangorestframework internally: /.../quickstart/mysite/mysite/settings.py 1 2 3 4 5 6 7 ... INSTALLED_APPS = [ 'polls' , 'rest_framework' , ... ] ... After adding the app to INSTALLED_APPS , perform migrations for creating required tables in DB. $ pwd /.../quickstart/mysite $ (qs) python3 manage.py makemigrations polls $ (qs) python3 manage.py migrate Add some data \u00b6 Since, our app and DB is setup, let us create some dummy data to play with them via REST api. $ pwd /.../quickstart/mysite $ python3 manage.py shell Python 3.8.10 (default, Mar 15 2022, 12:22:08) [GCC 9.4.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. (InteractiveConsole) >>> from polls.models import Question, Choice >>> from django.utils import timezone >>> q = Question(question_text=\"How is the traffic?\", pub_date=timezone.now()) >>> q.save() >>> q1 = Question(question_text=\"What's up?\", pub_date=timezone.now()) >>> q1.save() >>> q.choices.create(choice_text=\"Conjested\", votes=0) <Choice: Conjested> >>> q.choices.create(choice_text=\"Clear for miles\", votes=0) <Choice: Clear for miles> >>> q1.choices.create(choice_text=\"Fine\", votes=0) <Choice: Fine> >>> q1.choices.create(choice_text=\"Nohing New\", votes=0) <Choice: Nohing New> Use django-to-rest \u00b6 Now as we have some data to play with, let us use django-to-rest to create our api. To do that, we need to mark the models for which the REST apis need to be created. Let us mark our models for restification!!! (by restification, we mean to create REST api(s) for models): /.../quickstart/mysite/polls/models.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from django.db import models from django.utils import timezone from django.contrib import admin from to_rest.decorators import restifyModel # (1) # Create your models here. @restifyModel # (2) class Question ( models . Model ): question_text = models . CharField ( max_length = 200 ) pub_date = models . DateTimeField ( 'date published' ) def __str__ ( self ): return self . question_text @restifyModel # (3) class Choice ( models . Model ): question = models . ForeignKey ( Question , on_delete = models . CASCADE , related_name = 'choices' ) choice_text = models . CharField ( max_length = 200 ) votes = models . IntegerField ( default = 0 ) def __str__ ( self ): return self . choice_text Import the decorator from the library Note the way decorator is used Note the way decorator is used Now, go to projects urls.py and use the following method to get urls for REST apis: /.../quickstart/mysite/mysite/urls.py 1 2 3 4 5 6 7 8 from django.contrib import admin from django.urls import path from to_rest import utils # (1) urlpatterns = [ path ( 'admin/' , admin . site . urls ), ] urlpatterns . extend ( utils . restifyApp ( 'rest/v1' )) # (2) Import the utils from to_rest Use the method to get the urls. 'rest/v1' is the prefix for the urls for REST apis Now go to project's directory and start the server. $ pwd /.../quickstart/mysite $ python3 manage.py runserver Playing with REST apis \u00b6 Now open a new terminal check our apis using httpie: $ http --json http://127.0.0.1:8000/ HTTP/1.1 200 OK Allow: GET, HEAD, OPTIONS Content-Length: 143 Content-Type: application/json Cross-Origin-Opener-Policy: same-origin Date: Fri, 08 Jul 2022 11:02:17 GMT Referrer-Policy: same-origin Server: WSGIServer/0.2 CPython/3.8.10 Vary: Accept, Cookie X-Content-Type-Options: nosniff X-Frame-Options: DENY { \"rest/v1/polls/choice\": \"http://127.0.0.1:8000/rest/v1/polls/choice/\", \"rest/v1/polls/question\": \"http://127.0.0.1:8000/rest/v1/polls/question/\" } List objects \u00b6 $ http --json http://127.0.0.1:8000/rest/v1/polls/question/ HTTP/1.1 200 OK Allow: GET, POST, HEAD, OPTIONS Content-Length: 262 Content-Type: application/json Cross-Origin-Opener-Policy: same-origin Date: Fri, 08 Jul 2022 11:08:56 GMT Referrer-Policy: same-origin Server: WSGIServer/0.2 CPython/3.8.10 Vary: Accept, Cookie X-Content-Type-Options: nosniff X-Frame-Options: DENY [ { \"choices\": \"/rest/v1/polls/question/1/choices/\", \"id\": 1, \"pub_date\": \"2022-07-08T10:02:16.290713Z\", \"question_text\": \"How is the traffic?\" }, { \"choices\": \"/rest/v1/polls/question/2/choices/\", \"id\": 2, \"pub_date\": \"2022-07-08T10:03:15.816192Z\", \"question_text\": \"What's up?\" } ] Retreive object \u00b6 $ http --json http://127.0.0.1:8000/rest/v1/polls/question/1/ HTTP/1.1 200 OK Allow: GET, PUT, PATCH, DELETE, HEAD, OPTIONS Content-Length: 134 Content-Type: application/json Cross-Origin-Opener-Policy: same-origin Date: Fri, 08 Jul 2022 11:11:49 GMT Referrer-Policy: same-origin Server: WSGIServer/0.2 CPython/3.8.10 Vary: Accept, Cookie X-Content-Type-Options: nosniff X-Frame-Options: DENY { \"choices\": \"/rest/v1/polls/question/1/choices/\", \"id\": 1, \"pub_date\": \"2022-07-08T10:02:16.290713Z\", \"question_text\": \"How is the traffic?\" } List one-to-many objects \u00b6 $ http --json http://127.0.0.1:8000/rest/v1/polls/question/1/choices/ HTTP/1.1 200 OK Allow: GET, HEAD, OPTIONS Content-Length: 123 Content-Type: application/json Cross-Origin-Opener-Policy: same-origin Date: Fri, 08 Jul 2022 11:32:31 GMT Referrer-Policy: same-origin Server: WSGIServer/0.2 CPython/3.8.10 Vary: Accept, Cookie X-Content-Type-Options: nosniff X-Frame-Options: DENY [ { \"choice_text\": \"Conjested\", \"id\": 1, \"question\": 1, \"votes\": 0 }, { \"choice_text\": \"Clear for miles\", \"id\": 2, \"question\": 1, \"votes\": 0 } ] Filter using model attributes \u00b6 $ http --json http://127.0.0.1:8000/rest/v1/polls/question/1/choices/?choice_text=Conjested HTTP/1.1 200 OK Allow: GET, HEAD, OPTIONS Content-Length: 59 Content-Type: application/json Cross-Origin-Opener-Policy: same-origin Date: Fri, 08 Jul 2022 11:34:22 GMT Referrer-Policy: same-origin Server: WSGIServer/0.2 CPython/3.8.10 Vary: Accept, Cookie X-Content-Type-Options: nosniff X-Frame-Options: DENY [ { \"choice_text\": \"Conjested\", \"id\": 1, \"question\": 1, \"votes\": 0 } ] Search using model attributes \u00b6 $ http --json http://127.0.0.1:8000/rest/v1/polls/question/1/choices/?search=miles HTTP/1.1 200 OK Allow: GET, HEAD, OPTIONS Content-Length: 65 Content-Type: application/json Cross-Origin-Opener-Policy: same-origin Date: Fri, 08 Jul 2022 11:36:36 GMT Referrer-Policy: same-origin Server: WSGIServer/0.2 CPython/3.8.10 Vary: Accept, Cookie X-Content-Type-Options: nosniff X-Frame-Options: DENY [ { \"choice_text\": \"Clear for miles\", \"id\": 2, \"question\": 1, \"votes\": 0 } ] Ordering using model attributes \u00b6 $ http --json http://127.0.0.1:8000/rest/v1/polls/choice/?ordering=-choice_text HTTP/1.1 200 OK Allow: GET, POST, HEAD, OPTIONS Content-Length: 235 Content-Type: application/json Cross-Origin-Opener-Policy: same-origin Date: Fri, 08 Jul 2022 11:52:26 GMT Referrer-Policy: same-origin Server: WSGIServer/0.2 CPython/3.8.10 Vary: Accept, Cookie X-Content-Type-Options: nosniff X-Frame-Options: DENY [ { \"choice_text\": \"Nohing New\", \"id\": 4, \"question\": 2, \"votes\": 0 }, { \"choice_text\": \"Fine\", \"id\": 3, \"question\": 2, \"votes\": 0 }, { \"choice_text\": \"Conjested\", \"id\": 1, \"question\": 1, \"votes\": 0 }, { \"choice_text\": \"Clear for miles\", \"id\": 2, \"question\": 1, \"votes\": 0 } ] Partially update (PATCH) \u00b6 Note Here, httpie is used for examples. Hence, JSON like body is not used for PUT, PATCH, POST requests for body. Instead, httpie style is used. Other clients can also be used if any difficulty is faced. $ http PATCH http://127.0.0.1:8000/rest/v1/polls/choice/1/ choice_text=Highly\\ Conjested HTTP/1.1 200 OK Allow: GET, PUT, PATCH, DELETE, HEAD, OPTIONS Content-Length: 64 Content-Type: application/json Cross-Origin-Opener-Policy: same-origin Date: Fri, 08 Jul 2022 15:06:21 GMT Referrer-Policy: same-origin Server: WSGIServer/0.2 CPython/3.8.10 Vary: Accept, Cookie X-Content-Type-Options: nosniff X-Frame-Options: DENY { \"choice_text\": \"Highly Conjested\", \"id\": 1, \"question\": 1, \"votes\": 0 } Create (POST) \u00b6 $ http POST http://127.0.0.1:8000/rest/v1/polls/choice/ choice_text=Doing\\ bad question=2 votes=0 HTTP/1.1 201 Created Allow: GET, POST, HEAD, OPTIONS Content-Length: 57 Content-Type: application/json Cross-Origin-Opener-Policy: same-origin Date: Fri, 08 Jul 2022 15:19:40 GMT Referrer-Policy: same-origin Server: WSGIServer/0.2 CPython/3.8.10 Vary: Accept, Cookie X-Content-Type-Options: nosniff X-Frame-Options: DENY { \"choice_text\": \"Doing bad\", \"id\": 5, \"question\": 2, \"votes\": 0 }","title":"Quickstart Guide"},{"location":"quickstart/#setup","text":"Let us start fresh. Ensure that Python 3.8.x is already installed. It is always better to use virtual environment to isolate your work with other stuffs. Let us create and activate a virtual env inside the directory quickstart : # Create a virtual environment $ pwd /.../quickstart $ python3 -m venv qs $ source qs/bin/activate","title":"Setup"},{"location":"quickstart/#installation","text":"python3 -m pip install django-to-rest","title":"Installation"},{"location":"quickstart/#creation-of-a-django-project-and-app","text":"# Create a django project $ pwd /.../quickstart $ (qs) django-admin startproject mysite $ (qs) cd mysite # create an app in the project $ pwd /.../quickstart/mysite $ (qs) python3 manage.py startapp polls $ (qs) python3 manage.py migrate","title":"Creation of a django project and app"},{"location":"quickstart/#creation-of-models","text":"Now, let us create some models for our polls app. We will create one model named Question and another named Choice (This is quite similar to the tutoraial available at django documentation). Here, There will be one-to-many relationship from Question to Choice . /.../quickstart/mysite/polls/models.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from django.db import models from django.utils import timezone class Question ( models . Model ): question_text = models . CharField ( max_length = 200 ) pub_date = models . DateTimeField ( 'date published' ) def __str__ ( self ): return self . question_text class Choice ( models . Model ): question = models . ForeignKey ( Question , on_delete = models . CASCADE , related_name = 'choices' ) choice_text = models . CharField ( max_length = 200 ) votes = models . IntegerField ( default = 0 ) def __str__ ( self ): return self . choice_text","title":"Creation of models"},{"location":"quickstart/#activating-the-app","text":"Now, add the polls app to INSTALLED_APPS in settings.py . Also add rest_framework to it as djang-to-rest uses djangorestframework internally: /.../quickstart/mysite/mysite/settings.py 1 2 3 4 5 6 7 ... INSTALLED_APPS = [ 'polls' , 'rest_framework' , ... ] ... After adding the app to INSTALLED_APPS , perform migrations for creating required tables in DB. $ pwd /.../quickstart/mysite $ (qs) python3 manage.py makemigrations polls $ (qs) python3 manage.py migrate","title":"Activating the app"},{"location":"quickstart/#add-some-data","text":"Since, our app and DB is setup, let us create some dummy data to play with them via REST api. $ pwd /.../quickstart/mysite $ python3 manage.py shell Python 3.8.10 (default, Mar 15 2022, 12:22:08) [GCC 9.4.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. (InteractiveConsole) >>> from polls.models import Question, Choice >>> from django.utils import timezone >>> q = Question(question_text=\"How is the traffic?\", pub_date=timezone.now()) >>> q.save() >>> q1 = Question(question_text=\"What's up?\", pub_date=timezone.now()) >>> q1.save() >>> q.choices.create(choice_text=\"Conjested\", votes=0) <Choice: Conjested> >>> q.choices.create(choice_text=\"Clear for miles\", votes=0) <Choice: Clear for miles> >>> q1.choices.create(choice_text=\"Fine\", votes=0) <Choice: Fine> >>> q1.choices.create(choice_text=\"Nohing New\", votes=0) <Choice: Nohing New>","title":"Add some data"},{"location":"quickstart/#use-django-to-rest","text":"Now as we have some data to play with, let us use django-to-rest to create our api. To do that, we need to mark the models for which the REST apis need to be created. Let us mark our models for restification!!! (by restification, we mean to create REST api(s) for models): /.../quickstart/mysite/polls/models.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from django.db import models from django.utils import timezone from django.contrib import admin from to_rest.decorators import restifyModel # (1) # Create your models here. @restifyModel # (2) class Question ( models . Model ): question_text = models . CharField ( max_length = 200 ) pub_date = models . DateTimeField ( 'date published' ) def __str__ ( self ): return self . question_text @restifyModel # (3) class Choice ( models . Model ): question = models . ForeignKey ( Question , on_delete = models . CASCADE , related_name = 'choices' ) choice_text = models . CharField ( max_length = 200 ) votes = models . IntegerField ( default = 0 ) def __str__ ( self ): return self . choice_text Import the decorator from the library Note the way decorator is used Note the way decorator is used Now, go to projects urls.py and use the following method to get urls for REST apis: /.../quickstart/mysite/mysite/urls.py 1 2 3 4 5 6 7 8 from django.contrib import admin from django.urls import path from to_rest import utils # (1) urlpatterns = [ path ( 'admin/' , admin . site . urls ), ] urlpatterns . extend ( utils . restifyApp ( 'rest/v1' )) # (2) Import the utils from to_rest Use the method to get the urls. 'rest/v1' is the prefix for the urls for REST apis Now go to project's directory and start the server. $ pwd /.../quickstart/mysite $ python3 manage.py runserver","title":"Use django-to-rest"},{"location":"quickstart/#playing-with-rest-apis","text":"Now open a new terminal check our apis using httpie: $ http --json http://127.0.0.1:8000/ HTTP/1.1 200 OK Allow: GET, HEAD, OPTIONS Content-Length: 143 Content-Type: application/json Cross-Origin-Opener-Policy: same-origin Date: Fri, 08 Jul 2022 11:02:17 GMT Referrer-Policy: same-origin Server: WSGIServer/0.2 CPython/3.8.10 Vary: Accept, Cookie X-Content-Type-Options: nosniff X-Frame-Options: DENY { \"rest/v1/polls/choice\": \"http://127.0.0.1:8000/rest/v1/polls/choice/\", \"rest/v1/polls/question\": \"http://127.0.0.1:8000/rest/v1/polls/question/\" }","title":"Playing with REST apis"},{"location":"quickstart/#list-objects","text":"$ http --json http://127.0.0.1:8000/rest/v1/polls/question/ HTTP/1.1 200 OK Allow: GET, POST, HEAD, OPTIONS Content-Length: 262 Content-Type: application/json Cross-Origin-Opener-Policy: same-origin Date: Fri, 08 Jul 2022 11:08:56 GMT Referrer-Policy: same-origin Server: WSGIServer/0.2 CPython/3.8.10 Vary: Accept, Cookie X-Content-Type-Options: nosniff X-Frame-Options: DENY [ { \"choices\": \"/rest/v1/polls/question/1/choices/\", \"id\": 1, \"pub_date\": \"2022-07-08T10:02:16.290713Z\", \"question_text\": \"How is the traffic?\" }, { \"choices\": \"/rest/v1/polls/question/2/choices/\", \"id\": 2, \"pub_date\": \"2022-07-08T10:03:15.816192Z\", \"question_text\": \"What's up?\" } ]","title":"List objects"},{"location":"quickstart/#retreive-object","text":"$ http --json http://127.0.0.1:8000/rest/v1/polls/question/1/ HTTP/1.1 200 OK Allow: GET, PUT, PATCH, DELETE, HEAD, OPTIONS Content-Length: 134 Content-Type: application/json Cross-Origin-Opener-Policy: same-origin Date: Fri, 08 Jul 2022 11:11:49 GMT Referrer-Policy: same-origin Server: WSGIServer/0.2 CPython/3.8.10 Vary: Accept, Cookie X-Content-Type-Options: nosniff X-Frame-Options: DENY { \"choices\": \"/rest/v1/polls/question/1/choices/\", \"id\": 1, \"pub_date\": \"2022-07-08T10:02:16.290713Z\", \"question_text\": \"How is the traffic?\" }","title":"Retreive object"},{"location":"quickstart/#list-one-to-many-objects","text":"$ http --json http://127.0.0.1:8000/rest/v1/polls/question/1/choices/ HTTP/1.1 200 OK Allow: GET, HEAD, OPTIONS Content-Length: 123 Content-Type: application/json Cross-Origin-Opener-Policy: same-origin Date: Fri, 08 Jul 2022 11:32:31 GMT Referrer-Policy: same-origin Server: WSGIServer/0.2 CPython/3.8.10 Vary: Accept, Cookie X-Content-Type-Options: nosniff X-Frame-Options: DENY [ { \"choice_text\": \"Conjested\", \"id\": 1, \"question\": 1, \"votes\": 0 }, { \"choice_text\": \"Clear for miles\", \"id\": 2, \"question\": 1, \"votes\": 0 } ]","title":"List one-to-many objects"},{"location":"quickstart/#filter-using-model-attributes","text":"$ http --json http://127.0.0.1:8000/rest/v1/polls/question/1/choices/?choice_text=Conjested HTTP/1.1 200 OK Allow: GET, HEAD, OPTIONS Content-Length: 59 Content-Type: application/json Cross-Origin-Opener-Policy: same-origin Date: Fri, 08 Jul 2022 11:34:22 GMT Referrer-Policy: same-origin Server: WSGIServer/0.2 CPython/3.8.10 Vary: Accept, Cookie X-Content-Type-Options: nosniff X-Frame-Options: DENY [ { \"choice_text\": \"Conjested\", \"id\": 1, \"question\": 1, \"votes\": 0 } ]","title":"Filter using model attributes"},{"location":"quickstart/#search-using-model-attributes","text":"$ http --json http://127.0.0.1:8000/rest/v1/polls/question/1/choices/?search=miles HTTP/1.1 200 OK Allow: GET, HEAD, OPTIONS Content-Length: 65 Content-Type: application/json Cross-Origin-Opener-Policy: same-origin Date: Fri, 08 Jul 2022 11:36:36 GMT Referrer-Policy: same-origin Server: WSGIServer/0.2 CPython/3.8.10 Vary: Accept, Cookie X-Content-Type-Options: nosniff X-Frame-Options: DENY [ { \"choice_text\": \"Clear for miles\", \"id\": 2, \"question\": 1, \"votes\": 0 } ]","title":"Search using model attributes"},{"location":"quickstart/#ordering-using-model-attributes","text":"$ http --json http://127.0.0.1:8000/rest/v1/polls/choice/?ordering=-choice_text HTTP/1.1 200 OK Allow: GET, POST, HEAD, OPTIONS Content-Length: 235 Content-Type: application/json Cross-Origin-Opener-Policy: same-origin Date: Fri, 08 Jul 2022 11:52:26 GMT Referrer-Policy: same-origin Server: WSGIServer/0.2 CPython/3.8.10 Vary: Accept, Cookie X-Content-Type-Options: nosniff X-Frame-Options: DENY [ { \"choice_text\": \"Nohing New\", \"id\": 4, \"question\": 2, \"votes\": 0 }, { \"choice_text\": \"Fine\", \"id\": 3, \"question\": 2, \"votes\": 0 }, { \"choice_text\": \"Conjested\", \"id\": 1, \"question\": 1, \"votes\": 0 }, { \"choice_text\": \"Clear for miles\", \"id\": 2, \"question\": 1, \"votes\": 0 } ]","title":"Ordering using model attributes"},{"location":"quickstart/#partially-update-patch","text":"Note Here, httpie is used for examples. Hence, JSON like body is not used for PUT, PATCH, POST requests for body. Instead, httpie style is used. Other clients can also be used if any difficulty is faced. $ http PATCH http://127.0.0.1:8000/rest/v1/polls/choice/1/ choice_text=Highly\\ Conjested HTTP/1.1 200 OK Allow: GET, PUT, PATCH, DELETE, HEAD, OPTIONS Content-Length: 64 Content-Type: application/json Cross-Origin-Opener-Policy: same-origin Date: Fri, 08 Jul 2022 15:06:21 GMT Referrer-Policy: same-origin Server: WSGIServer/0.2 CPython/3.8.10 Vary: Accept, Cookie X-Content-Type-Options: nosniff X-Frame-Options: DENY { \"choice_text\": \"Highly Conjested\", \"id\": 1, \"question\": 1, \"votes\": 0 }","title":"Partially update (PATCH)"},{"location":"quickstart/#create-post","text":"$ http POST http://127.0.0.1:8000/rest/v1/polls/choice/ choice_text=Doing\\ bad question=2 votes=0 HTTP/1.1 201 Created Allow: GET, POST, HEAD, OPTIONS Content-Length: 57 Content-Type: application/json Cross-Origin-Opener-Policy: same-origin Date: Fri, 08 Jul 2022 15:19:40 GMT Referrer-Policy: same-origin Server: WSGIServer/0.2 CPython/3.8.10 Vary: Accept, Cookie X-Content-Type-Options: nosniff X-Frame-Options: DENY { \"choice_text\": \"Doing bad\", \"id\": 5, \"question\": 2, \"votes\": 0 }","title":"Create (POST)"},{"location":"community/changelogs/","text":"Django-to-rest 1.0.0b2 \u00b6 Fixed readme.rst file Django-to-rest 1.0.0b1 \u00b6 Bug fixes related to nested urls for relationship Custom view parameters now applies to nested urls Support for adding custom methods as view parameters Support for customizing behaviour for nested urls for relationship Any other custom parameters for view set can be passed to the decorator Support for urls with and without trailing slashes Updated documentation with following topics: Adding throttling options Adding custom mfiltering Adding methods Relationships Django-to-rest 0.1a3 \u00b6 First basic pre-release Nested urls for one-to-one, many-to-one, and many-to-many Documentaion with topics: Marking models Custom serializer Custom Authentication class Custom Permission class","title":"Changelogs"},{"location":"community/changelogs/#django-to-rest-100b2","text":"Fixed readme.rst file","title":"Django-to-rest 1.0.0b2"},{"location":"community/changelogs/#django-to-rest-100b1","text":"Bug fixes related to nested urls for relationship Custom view parameters now applies to nested urls Support for adding custom methods as view parameters Support for customizing behaviour for nested urls for relationship Any other custom parameters for view set can be passed to the decorator Support for urls with and without trailing slashes Updated documentation with following topics: Adding throttling options Adding custom mfiltering Adding methods Relationships","title":"Django-to-rest 1.0.0b1"},{"location":"community/changelogs/#django-to-rest-01a3","text":"First basic pre-release Nested urls for one-to-one, many-to-one, and many-to-many Documentaion with topics: Marking models Custom serializer Custom Authentication class Custom Permission class","title":"Django-to-rest 0.1a3"},{"location":"community/contributing_to_django_to_rest/","text":"Thank you for your interest in contrubiting to this project. Please get involved and help to make the project better. The contributions can be in the form of ideas, development, documentations and testing in the form test scripts. Code of Conduct \u00b6 Check this link for code of conduct: Code of Conduct Issues \u00b6 Ensure that you discuss the topic before raising an issue. Check Github discussions page for discussions. Ensure that the issues are properly explained Before raising an issue check if similar issue already exists in Github issues page Development \u00b6 To start developing: First create a fork Clone your fork It is recommended to have a virtual environment Install django 4.0.5 , django-rest-framework 3.13.1 and django-filter 22.1 Create new branch Start you development on the new branch... To test your changes in a django project install the project from your local machine using the command: python3 -m pip install path-to-project's-directory . For example, if the directory django-to-rest is in ~/project/ then the command would be python3 -m pip install ~/project/django-to-rest/ And then follow the Quickstart Guide for better understanding. Note that the project needs to be installed from the local machine and not from PyPi. See GitHub's Fork a Repo Guide for more help. Testing \u00b6 Note Apart from development, you can also contribute test scripts to cover the scenarios that are not covered yet to make the project better. There are five apps in the tests directory for testing different scenarios: tests/test_basics To test generic scenarios Command to run test: $ python3 manage.py test test_basics tests/test_basics_defaults To test generic scenarios with configuration in settings file For this app there is a dedicated settings file at tests/tests/settings_test_basics_defaults.py Command to run test: $ python3 manage.py test test_basics_defaults --settings=tests.settings_test_basics_defaults tests/test_many_to_many To test scenarios related to many-to-many relationship Command to run test: $ python3 manage.py test test_many_to_many tests/test_many_to_one To test scenarios related to many-to-one relationship Command to run test: $ python3 manage.py test test_many_to_one tests/test_one_to_one To test scenarios related to one-to-one relationship Command to run test: $ python3 manage.py test test_one_to_one Before running any test first install django-to-rest by executing below command at the root directory of the repository (where the setup.py resides). This will also install other packages required (that are mentioned in the Development section): $ python3 -m pip install ./ Whenever any change in code is made, uninstall django-to-rest: $ python3 -m pip uninstall django-to-rest And then install again to run the test on the updated code. Ensure that the test scripts are well commented so that one can understand about the scenario for which it is tested. Check existing scripts for example. Documentation \u00b6 The documentation is made using Material for Mkdocs . All the files related to documentation is inside docs directory. Just update the code and hit below command to preview: $ mkdocs serve Check Material for Mkdocs for more help. Contribute and make pull request \u00b6 All the contributions have to be made via a pull request. After you have cloned the forked repository, follow below steps: Go into the project's directory (that is django-to-rest ) Create a new branch using following command in the command line: git branch new-branch-name Checkout to the new branch using following command in the command line: git checkout new-branch-name Make the changes that you want to contribute Stage your changes using the following command in command line: git command . Check the status using the command: git status Commit your changes using the command: git commit -m \"commit message\" Push your changes to the remote branch on GitHub by using the following command: git push -u origin branch_name Open a pull request directed to our master branch For tutorials on pull request check below links: Github: About pull request W3schools: Send Pull Request","title":"Contributing to django-to-rest"},{"location":"community/contributing_to_django_to_rest/#code-of-conduct","text":"Check this link for code of conduct: Code of Conduct","title":"Code of Conduct"},{"location":"community/contributing_to_django_to_rest/#issues","text":"Ensure that you discuss the topic before raising an issue. Check Github discussions page for discussions. Ensure that the issues are properly explained Before raising an issue check if similar issue already exists in Github issues page","title":"Issues"},{"location":"community/contributing_to_django_to_rest/#development","text":"To start developing: First create a fork Clone your fork It is recommended to have a virtual environment Install django 4.0.5 , django-rest-framework 3.13.1 and django-filter 22.1 Create new branch Start you development on the new branch... To test your changes in a django project install the project from your local machine using the command: python3 -m pip install path-to-project's-directory . For example, if the directory django-to-rest is in ~/project/ then the command would be python3 -m pip install ~/project/django-to-rest/ And then follow the Quickstart Guide for better understanding. Note that the project needs to be installed from the local machine and not from PyPi. See GitHub's Fork a Repo Guide for more help.","title":"Development"},{"location":"community/contributing_to_django_to_rest/#testing","text":"Note Apart from development, you can also contribute test scripts to cover the scenarios that are not covered yet to make the project better. There are five apps in the tests directory for testing different scenarios: tests/test_basics To test generic scenarios Command to run test: $ python3 manage.py test test_basics tests/test_basics_defaults To test generic scenarios with configuration in settings file For this app there is a dedicated settings file at tests/tests/settings_test_basics_defaults.py Command to run test: $ python3 manage.py test test_basics_defaults --settings=tests.settings_test_basics_defaults tests/test_many_to_many To test scenarios related to many-to-many relationship Command to run test: $ python3 manage.py test test_many_to_many tests/test_many_to_one To test scenarios related to many-to-one relationship Command to run test: $ python3 manage.py test test_many_to_one tests/test_one_to_one To test scenarios related to one-to-one relationship Command to run test: $ python3 manage.py test test_one_to_one Before running any test first install django-to-rest by executing below command at the root directory of the repository (where the setup.py resides). This will also install other packages required (that are mentioned in the Development section): $ python3 -m pip install ./ Whenever any change in code is made, uninstall django-to-rest: $ python3 -m pip uninstall django-to-rest And then install again to run the test on the updated code. Ensure that the test scripts are well commented so that one can understand about the scenario for which it is tested. Check existing scripts for example.","title":"Testing"},{"location":"community/contributing_to_django_to_rest/#documentation","text":"The documentation is made using Material for Mkdocs . All the files related to documentation is inside docs directory. Just update the code and hit below command to preview: $ mkdocs serve Check Material for Mkdocs for more help.","title":"Documentation"},{"location":"community/contributing_to_django_to_rest/#contribute-and-make-pull-request","text":"All the contributions have to be made via a pull request. After you have cloned the forked repository, follow below steps: Go into the project's directory (that is django-to-rest ) Create a new branch using following command in the command line: git branch new-branch-name Checkout to the new branch using following command in the command line: git checkout new-branch-name Make the changes that you want to contribute Stage your changes using the following command in command line: git command . Check the status using the command: git status Commit your changes using the command: git commit -m \"commit message\" Push your changes to the remote branch on GitHub by using the following command: git push -u origin branch_name Open a pull request directed to our master branch For tutorials on pull request check below links: Github: About pull request W3schools: Send Pull Request","title":"Contribute and make pull request"},{"location":"full_guide/adding_auth/","text":"Note It is advised to go through point 2 of Marking models to create REST APIs and Adding Custom Serializer and have an understanding of passing custom view attributes. Here, only example of view_params is given. To add authentication class, the dictionary returned by getParams() method of a ViewParams class must have an entry with key constants.AUTHENTICATION_CLASSES . For example: view_params.py 1 2 3 4 5 6 7 8 9 10 11 from to_rest import constants from test_basics import serializers # (1) from to_rest.utils import ViewParams class CustomAuthAndPermission ( ViewParams ): def getParams (): temp = dict () temp [ constants . AUTHENTICATION_CLASSES ] = [ BasicAuthentication ] temp [ constants . PERMISSION_CLASSES ] = [ IsAuthenticatedOrReadOnly ] return temp Here, test_basics is the directory of the app Ensure that the name of the class is passed to the decorator restifyModel() in models.py . For example: models.py 1 2 3 4 5 6 7 8 9 from django.db import models from to_rest.decorators import restifyModel @restifyModel ( customViewParams = 'CustomAuthAndPermission' ) class StudentWithCustomAuthAndPermission ( models . Model ): name = models . CharField ( max_length = 50 ) def __str__ ( self ): return \"[name= {} ]\" . format ( self . name )","title":"Adding Authentication class"},{"location":"full_guide/adding_custom_classes/","text":"Apart from what the tool does, all the other functionalities given by Django REST Framework can be added in the way it is normally done. Note Name of any other custom classes must not start with DjangoToRest_ .","title":"Adding custom views, viewsets, etc"},{"location":"full_guide/adding_custom_filtering/","text":"Note It is advised to go through point 2 of Marking models to create REST APIs and Adding Custom Serializer and have an understanding of passing custom view attributes. For filtering, following keys can be used in the dictionary that would be returned from the getParams() method of a ViewParams class: to_rest.constants.FILTER_BACKENDS: To specify filter backends to_rest.constants.FILTERSET_FIELDS: To specify filterset fields to_rest.constants.SEARCH_FIELDS: To specify search fields to_rest.constants.ORDERING_FIELDS: To specify ordering fields to_rest.constants.ORDERING: To specify default ordering to_rest.constants.FILTERSET_CLASS: To specify filterset class Note If both to_rest.constants.FILTERSET_CLASS and to_rest.constants.FILTERSET_FIELDS are used then to_rest.constants.FILTERSET_CLASS is given preference and to_rest.constants.FILTERSET_FIELDS is ignored. For example, let us consider the below model: models.py 1 2 3 4 5 6 7 8 9 from django.db import models class StudentWithCustomFiltering ( models . Model ): name = models . CharField ( max_length = 50 ) year = models . IntegerField () discipline = models . CharField ( max_length = 20 ) def __str__ ( self ): return \"[name= {} ]\" . format ( self . name ) For above model, various filtering attributes can be provided via a ViewParams class. For example: view_params.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from to_rest import constants from to_rest.utils import ViewParams from rest_framework.filters import SearchFilter , OrderingFilter from test_basics import filterset # (1) from django_filters.rest_framework import DjangoFilterBackend class CustomFiltering ( ViewParams ): def getParams (): temp = dict () temp [ constants . FILTER_BACKENDS ] = [ DjangoFilterBackend , SearchFilter , OrderingFilter ] temp [ constants . FILTERSET_FIELDS ] = [ 'name' , 'year' , 'discipline' ] temp [ constants . SEARCH_FIELDS ] = [ 'name' ] temp [ constants . ORDERING_FIELDS ] = [ 'discipline' , 'year' ] temp [ constants . ORDERING ] = [ 'year' ] return temp Here, test_basics is the directory of app Ensure that the name of the class is passed to the decorator restifyModel() in models.py . For example: models.py 1 2 3 4 5 6 7 8 9 10 11 from django.db import models from to_rest.decorators import restifyModel @restifyModel ( customViewParams = 'CustomFiltering' ) class StudentWithCustomFiltering ( models . Model ): name = models . CharField ( max_length = 50 ) year = models . IntegerField () discipline = models . CharField ( max_length = 20 ) def __str__ ( self ): return \"[name= {} ]\" . format ( self . name )","title":"Adding custom Filtering"},{"location":"full_guide/adding_custom_serializer/","text":"Note It is advised to go through point 2 of Marking models to create REST APIs Let us consider the below model: models.py 1 2 3 4 5 6 7 from django.db import models class StudentWithCustomSerializer ( models . Model ): name = models . CharField ( max_length = 50 ) def __str__ ( self ): return \"[name= {} , year= {} ]\" . format ( self . name , self . year ) A simple serializer for the model above is given below: serializers.py 1 2 3 4 5 6 7 8 9 10 from rest_framework import serializers from test_basics.models import StudentWithCustomSerializer # (1) class StudentWithCustomSerializerSerializer ( serializers . Serializer ): id = serializers . IntegerField ( read_only = True ) name = serializers . CharField () def create ( self , validated_data ): return StudentWithCustomSerializer . objects . create ( ** validated_data ) Here, test_basics is the directory of the app As mentioned in Marking models to create REST APIs , all the custom parameters for view needs to be mentioned in a ViewParams class and all such class needs to be in module view_params in the directory of the app. Let us create a new file in the same working directory called view_params.py and create a class as shown below: view_params.py 1 2 3 4 5 6 7 8 9 10 from to_rest import constants from test_basics import serializers # (1) from to_rest.utils import ViewParams class CustomSerializer ( ViewParams ): def getParams (): temp = dict () temp [ constants . SERIALIZER_CLASS ] = serializers . StudentWithCustomSerializerSerializer return temp Here, test_basics is the directory of the app Note that the dictionary returned by getParams() must contain an entry with key to_rest.constants.SERIALIZER_CLASS . Now, let us go back to models.py and see how to provide the custom serializer that we created. models.py 1 2 3 4 5 6 7 8 9 from django.db import models from to_rest.decorators import restifyModel @restifyModel ( customViewParams = 'CustomSerializer' ) class StudentWithCustomSerializer ( models . Model ): name = models . CharField ( max_length = 50 ) def __str__ ( self ): return \"[name= {} , year= {} ]\" . format ( self . name , self . year ) Note the way CustomSerializer is passed to the decorator at line 4.","title":"Adding custom Serializer"},{"location":"full_guide/adding_methods/","text":"Adding a normal method \u00b6 Any methods can be added to the view set using a ViewParams class. To add a method, an element of dictionary returned by getParams() method of the ViewParams class should have a key as name of the method (str) and the value should be reference to the function object. For example, to use custom list() method instead of the one given by django-to-rest something similar to below example can be used: view_params.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from to_rest import constants from to_rest.utils import ViewParams from test_basics import models # Here, test_basics is the app directory class CustomListMethod ( ViewParams ): def getParams (): def list ( self , request , * args , ** kwargs ): objects = models . StudentWithCustomMethod . objects . filter ( year = 2 ) serializer = self . get_serializer ( objects , many = True ) return Response ( serializer . data ) temp = dict () temp [ 'list' ] = list return temp Note The name of this class has to be passed to the decorator in models.py . Similarly, any method can be added to the view set. Adding a decorated method \u00b6 Let us consider the following decorated method: decorator with no parameters 1 2 3 @decorator def function (): pass The above decorated function is same as: 1 2 3 def function (): pass function = decorator ( function ) Moreover, following decorated method: decorater with parameters 1 2 3 @decorator ( param1 = abc ) def function (): pass Above is same as: 1 2 3 def function (): pass function = decorator ( param1 = abc )( function ) Hence, to add decorated method, instead of using @ notation we just need to use the later. Below is an example of adding an action: view_params.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from to_rest import constants from to_rest.utils import ViewParams from test_basics import models # Here, test_basics is the app directory from rest_framework.response import Response from rest_framework.decorators import action class CustomAction ( ViewParams ): def getParams (): def customaction ( self , request , pk = None ): obj = models . StudentWithCustomAction . objects . get ( pk = pk ) return Response ({ 'msg' : \"custom action working for \" + obj . name }) customaction = action ( detail = True , methods = [ 'get' ], url_name = 'customaction' )( customaction ) temp = dict () temp [ 'customaction' ] = customaction return temp Note the way the decorator is used at line 13.","title":"Adding methods"},{"location":"full_guide/adding_methods/#adding-a-normal-method","text":"Any methods can be added to the view set using a ViewParams class. To add a method, an element of dictionary returned by getParams() method of the ViewParams class should have a key as name of the method (str) and the value should be reference to the function object. For example, to use custom list() method instead of the one given by django-to-rest something similar to below example can be used: view_params.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from to_rest import constants from to_rest.utils import ViewParams from test_basics import models # Here, test_basics is the app directory class CustomListMethod ( ViewParams ): def getParams (): def list ( self , request , * args , ** kwargs ): objects = models . StudentWithCustomMethod . objects . filter ( year = 2 ) serializer = self . get_serializer ( objects , many = True ) return Response ( serializer . data ) temp = dict () temp [ 'list' ] = list return temp Note The name of this class has to be passed to the decorator in models.py . Similarly, any method can be added to the view set.","title":"Adding a normal method"},{"location":"full_guide/adding_methods/#adding-a-decorated-method","text":"Let us consider the following decorated method: decorator with no parameters 1 2 3 @decorator def function (): pass The above decorated function is same as: 1 2 3 def function (): pass function = decorator ( function ) Moreover, following decorated method: decorater with parameters 1 2 3 @decorator ( param1 = abc ) def function (): pass Above is same as: 1 2 3 def function (): pass function = decorator ( param1 = abc )( function ) Hence, to add decorated method, instead of using @ notation we just need to use the later. Below is an example of adding an action: view_params.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from to_rest import constants from to_rest.utils import ViewParams from test_basics import models # Here, test_basics is the app directory from rest_framework.response import Response from rest_framework.decorators import action class CustomAction ( ViewParams ): def getParams (): def customaction ( self , request , pk = None ): obj = models . StudentWithCustomAction . objects . get ( pk = pk ) return Response ({ 'msg' : \"custom action working for \" + obj . name }) customaction = action ( detail = True , methods = [ 'get' ], url_name = 'customaction' )( customaction ) temp = dict () temp [ 'customaction' ] = customaction return temp Note the way the decorator is used at line 13.","title":"Adding a decorated method"},{"location":"full_guide/adding_permission/","text":"Note It is advised to go through point 2 of Marking models to create REST APIs and Adding Custom Serializer and have an understanding of passing custom view attributes. Here, only example of view_params is given. To add custom permission class, the dictionary returned by getParams() method of a ViewParams class must have an entry with key constants.PERMISSION_CLASSES . For example: view_params.py 1 2 3 4 5 6 7 8 9 10 11 from to_rest import constants from test_basics import serializers # (1) from to_rest.utils import ViewParams class CustomAuthAndPermission ( ViewParams ): def getParams (): temp = dict () temp [ constants . AUTHENTICATION_CLASSES ] = [ BasicAuthentication ] temp [ constants . PERMISSION_CLASSES ] = [ IsAuthenticatedOrReadOnly ] return temp Here, test_basics is the directory of the app Ensure that the name of the class is passed to the decorator restifyModel() in models.py . For example: models.py 1 2 3 4 5 6 7 8 9 from django.db import models from to_rest.decorators import restifyModel @restifyModel ( customViewParams = 'CustomAuthAndPermission' ) class StudentWithCustomAuthAndPermission ( models . Model ): name = models . CharField ( max_length = 50 ) def __str__ ( self ): return \"[name= {} ]\" . format ( self . name )","title":"Adding Permission class"},{"location":"full_guide/adding_throttling/","text":"Note It is advised to go through point 2 of Marking models to create REST APIs and Adding Custom Serializer and have an understanding of passing custom view attributes. Here, an example of ScopedRateThrottle class is given as other types of classes and options can be managed solely via settings.py . Let us consider the below model: models.py 1 2 3 4 5 6 7 from django.db import models class StudentWithCustomThrottling ( models . Model ): name = models . CharField ( max_length = 50 ) def __str__ ( self ): return \"[name= {} ]\" . format ( self . name ) To add throttling class, the dictionary returned by getParams() method of a ViewParams class must have an entry with key constants.THROTTLE_SCOPE . For example: view_params.py 1 2 3 4 5 6 7 8 9 from to_rest import constants from to_rest.utils import ViewParams class CustomThrottling ( ViewParams ): def getParams (): temp = dict () temp [ constants . THROTTLE_SCOPE ] = \"studentCustomThrottle\" return temp Now, let us go back to models.py and see how to provide the throttle scope as viewset attribute. models.py 1 2 3 4 5 6 7 8 9 from django.db import models from to_rest.decorators import restifyModel @restifyModel ( customViewParams = 'CustomThrottling' ) class StudentWithCustomThrottling ( models . Model ): name = models . CharField ( max_length = 50 ) def __str__ ( self ): return \"[name= {} ]\" . format ( self . name ) Also, ensure that throttle class and other options are specified in settings.py : settings.py 1 2 3 4 5 6 7 8 9 10 11 ... REST_FRAMEWORK = { ... 'DEFAULT_THROTTLE_CLASSES' : [ 'rest_framework.throttling.ScopedRateThrottle' , ], 'DEFAULT_THROTTLE_RATES' : { 'studentCustomThrottle' : '5/min' } ... }","title":"Adding throttling options"},{"location":"full_guide/marking_model_for_REST/","text":"To create REST APIs for a model, first we need to mark the model. And to mark the model, use the decorator to_rest.decorators.restifyModel . The decorator can be used in the following two ways: Without Parameters : When used without parameters, all the defaults would be applied. For example: /.../quickstart/mysite/polls/models.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from django.db import models from django.utils import timezone from django.contrib import admin from to_rest.decorators import restifyModel # (1) # Create your models here. @restifyModel # (2) class Question ( models . Model ): question_text = models . CharField ( max_length = 200 ) pub_date = models . DateTimeField ( 'date published' ) def __str__ ( self ): return self . question_text @restifyModel # (3) class Choice ( models . Model ): question = models . ForeignKey ( Question , on_delete = models . CASCADE , related_name = 'choices' ) choice_text = models . CharField ( max_length = 200 ) votes = models . IntegerField ( default = 0 ) def __str__ ( self ): return self . choice_text Import the decorator from the library Note the way decorator is used Note the way decorator is used With Parameters : The decorator accepts the following parameters customViewParams (str) : This accepts the name of a ViewParams class. The ViewParams class needs to override the class method getParams() to provide customized methods and attributes for view set. For example, custom serializer, list method, create method, retreive method, update method, partial_update method, delete method, get_object method, get_queryset, etc. The getParams() method must return a dictionary. excludeFields (list) : The fields that needs to be excluded from the JSON object. Provided fields will not be included in the serializer. If customSerializer is provided then this parameter will be ignored. methodFields (list) : The list of methods as read only fields. This can be used to include the model's methods' output as field. This includes only those field that don't take any parameter. An example of passing custom serializer is given below: serializers.py view_params.py models.py 1 2 3 4 5 6 7 8 9 10 from rest_framework import serializers from test_basics.models import StudentWithCustomSerializer # (1) class StudentWithCustomSerializerSerializer ( serializers . Serializer ): id = serializers . IntegerField ( read_only = True ) name = serializers . CharField () def create ( self , validated_data ): return StudentWithCustomSerializer . objects . create ( ** validated_data ) Here, test_basics is the directory of the app 1 2 3 4 5 6 7 8 9 10 from to_rest import constants from test_basics import serializers # (1) from to_rest.utils import ViewParams class CustomSerializer ( ViewParams ): def getParams (): temp = dict () temp [ constants . SERIALIZER_CLASS ] = serializers . StudentWithCustomSerializerSerializer return temp Here, test_basics is the directory of the app 1 2 3 4 5 6 7 8 9 from django.db import models from to_rest.decorators import restifyModel @restifyModel ( customViewParams = 'CustomSerializer' ) class StudentWithCustomSerializer ( models . Model ): name = models . CharField ( max_length = 50 ) def __str__ ( self ): return \"[name= {} , year= {} ]\" . format ( self . name , self . year ) In the above example, a custom serializer has been created in serializers.py . A ViewParams class, CustomSerializer is created in view_params.py to provide the custom serializer. And the name of the ViewParams class is provided in decorator at line 4 in models.py . Note All ViewParams classes must be in the module view_params in the directory of the app. That means, in the same location where models.py is located. Django-to-rest will get the name of the ViewParams class from the decorator and will search that class in the module view_params. Hence, in the example above, CustomSerializer is created in view_params.py .","title":"Marking models to create REST APIs"},{"location":"full_guide/relationships/","text":"One-to-one relationships \u00b6 This section shows the behaviour for one to one relationship: Consider following models: models.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from django.db import models from to_rest.decorators import restifyModel # Create your models here. @restifyModel class Student ( models . Model ): name = models . CharField ( max_length = 75 ) discipline = models . CharField ( max_length = 10 ) program = models . CharField ( max_length = 10 ) def __str__ ( self ): return \"[name= {} ; discipline= {} ; program= {} ]\" . format ( self . name , self . discipline , self . program ) @restifyModel class System ( models . Model ): name = models . CharField ( max_length = 75 ) location = models . CharField ( max_length = 20 ) student = models . OneToOneField ( Student , models . CASCADE , null = True ) def __str__ ( self ): return \"[name= {} ; location= {} ]\" . format ( self . name , self . location ) In the above models, there is a one-to-one relationship from System1 to Student1. Let us create a student object: $ http POST http://127.0.0.1:8000/rest/v1/lab/student/ name=John\\ Doe discipline=CS program=MS HTTP/1.1 201 Created Allow: GET, POST, HEAD, OPTIONS Content-Length: 73 Content-Type: application/json Cross-Origin-Opener-Policy: same-origin Date: Fri, 30 Sep 2022 09:47:29 GMT Referrer-Policy: same-origin Server: WSGIServer/0.2 CPython/3.10.6 Vary: Accept, Cookie X-Content-Type-Options: nosniff X-Frame-Options: DENY { \"discipline\": \"CS\", \"id\": 1, \"name\": \"John Doe\", \"program\": \"MS\", \"system\": null } Here, the student object has got an attribute, \"system\" which is null as this student object is not yet mapped with any system object. This attribute is a field of type OneToOneRel and not of type OneToOneField . Thus, this is a read-only field. This field will get some value when this object is mapped with a System object. Let us create a system object: $ http POST http://127.0.0.1:8000/rest/v1/lab/system/ name=Dell\\ Vostro\\ 1558 location=AB1-102 HTTP/1.1 201 Created Allow: GET, POST, HEAD, OPTIONS Content-Length: 70 Content-Type: application/json Cross-Origin-Opener-Policy: same-origin Date: Fri, 30 Sep 2022 11:27:53 GMT Referrer-Policy: same-origin Server: WSGIServer/0.2 CPython/3.10.6 Vary: Accept, Cookie X-Content-Type-Options: nosniff X-Frame-Options: DENY { \"id\": 1, \"location\": \"AB1-102\", \"name\": \"Dell Vostro 1558\", \"student\": null } Note In the model, the null flag for the OneToOneField is set as True . Not allowing null values may have restrictions on updating relations. The \"student\" attribute here is OneToOneField and is read-write. Now, this object can be used to map \"Student\" and \"System\" object as shown below: $ http PATCH http://127.0.0.1:8000/rest/v1/lab/system/1/ student=1 HTTP/1.1 200 OK Allow: GET, PUT, PATCH, DELETE, HEAD, OPTIONS Content-Length: 67 Content-Type: application/json Cross-Origin-Opener-Policy: same-origin Date: Fri, 30 Sep 2022 20:11:52 GMT Referrer-Policy: same-origin Server: WSGIServer/0.2 CPython/3.10.6 Vary: Accept, Cookie X-Content-Type-Options: nosniff X-Frame-Options: DENY { \"id\": 1, \"location\": \"AB1-102\", \"name\": \"Dell Vostro 1558\", \"student\": 1 } $ http PATCH http://127.0.0.1:8000/rest/v1/lab/student/1/ HTTP/1.1 200 OK Allow: GET, PUT, PATCH, DELETE, HEAD, OPTIONS Content-Length: 70 Content-Type: application/json Cross-Origin-Opener-Policy: same-origin Date: Fri, 30 Sep 2022 20:12:47 GMT Referrer-Policy: same-origin Server: WSGIServer/0.2 CPython/3.10.6 Vary: Accept, Cookie X-Content-Type-Options: nosniff X-Frame-Options: DENY { \"discipline\": \"CS\", \"id\": 1, \"name\": \"John Doe\", \"program\": \"MS\", \"system\": 1 } Notice that the student object now shows primary key of related \"System\" object. Many-to-one relationships \u00b6 This section shows the behaviour for many to one relationship: Consider the following model: models.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from django.db import models from django.utils import timezone from to_rest.decorators import restifyModel # Create your models here. @restifyModel class Question ( models . Model ): question_text = models . CharField ( max_length = 200 ) def pub_date_default (): return timezone . now () pub_date = models . DateTimeField ( 'date published' , default = pub_date_default ) @restifyModel class Choice ( models . Model ): question = models . ForeignKey ( Question , on_delete = models . CASCADE , related_name = 'choices' ) choice_text = models . CharField ( max_length = 200 ) votes = models . IntegerField ( default = 0 ) In the above models there is a many-to-one relationship from Choice to Question . This will create a read only field called choices which will have link for the related choices object. For example: $ http GET http://127.0.0.1:8000/rest/v1/polls/question/ HTTP/1.1 200 OK Allow: GET, POST, HEAD, OPTIONS Content-Length: 136 Content-Type: application/json Cross-Origin-Opener-Policy: same-origin Date: Sun, 02 Oct 2022 09:30:42 GMT Referrer-Policy: same-origin Server: WSGIServer/0.2 CPython/3.10.6 Vary: Accept, Cookie X-Content-Type-Options: nosniff X-Frame-Options: DENY [ { \"choices\": \"/rest/v1/polls/question/1/choices/\", \"id\": 1, \"pub_date\": \"2022-10-02T09:23:28.297936Z\", \"question_text\": \"How is the traffic?\" } ] On fetching the link for choices we get all the related Choice object: $ http -b GET http://127.0.0.1:8000/rest/v1/polls/question/1/choices/ [ { \"choice_text\": \"Clear for miles...\", \"id\": 1, \"question\": 1, \"votes\": 0 }, { \"choice_text\": \"Stuck for an hour\", \"id\": 2, \"question\": 1, \"votes\": 0 } ] Note This url is only for list operations as all the other operations like create, update and delete can be done from the other side of the relationship. All the other view set attributes like permission_classes , filter_backends , ... applies as provided to the decorator in models.py. For example conside following models and view_params : view_params.py models.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from to_rest import constants from rest_framework.permissions import DjangoModelPermissions , IsAuthenticated from to_rest.utils import ViewParams from rest_framework.authentication import BasicAuthentication class DDjangoModelPermissions ( DjangoModelPermissions ): perms_map = { 'GET' : [ ' %(app_label)s .view_ %(model_name)s ' ], 'POST' : [ ' %(app_label)s .add_ %(model_name)s ' ], 'PUT' : [ ' %(app_label)s .update_ %(model_name)s ' ], 'PATCH' : [ ' %(app_label)s .update_ %(model_name)s ' ], 'DELETE' : [ ' %(app_label)s .delete_ %(model_name)s ' ] } class CustomPermission ( ViewParams ): def getParams (): temp = dict () temp [ constants . AUTHENTICATION_CLASSES ] = [ BasicAuthentication ] temp [ constants . PERMISSION_CLASSES ] = [ IsAuthenticated , DDjangoModelPermissions ] return temp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from django.db import models from django.utils import timezone from to_rest.decorators import restifyModel # Create your models here. @restifyModel ( customViewParams = 'CustomPermission' ) class Question1 ( models . Model ): question_text = models . CharField ( max_length = 200 ) def pub_date_default (): return timezone . now () pub_date = models . DateTimeField ( 'date published' , default = pub_date_default ) @restifyModel ( customViewParams = 'CustomPermission' ) class Choice1 ( models . Model ): question = models . ForeignKey ( Question1 , on_delete = models . CASCADE , related_name = 'choices' ) choice_text = models . CharField ( max_length = 200 ) votes = models . IntegerField ( default = 0 ) Now, if a user has all permissions for Question1 and not for Choice1 then the user can access the url(s) for Question1 but not the nested url for related Choice1 objects: $ http -b -a testy:test@1234 GET http://127.0.0.1:8000/rest/v1/polls/question1/ [ { \"choices\": \"/rest/v1/polls/question1/1/choices/\", \"id\": 1, \"pub_date\": \"2022-10-02T09:23:47.805702Z\", \"question_text\": \"How is the traffic?\" } ] $ http -b -a testy:test@1234 GET http://127.0.0.1:8000/rest/v1/polls/question1/1/choices/ { \"detail\": \"You do not have permission to perform this action.\" } Many-to-many relationships \u00b6 In case of many-to-many relationships, through objects for the related objects are returned from the nested url instead of the related objects as through objects have better information about the relationship. Nested url for many-to-many relationships support following operations: list (GET) create (POST) retrieve (GET) update (PUT) partial_update (PATCH) delete (DELETE) All the other view set attributes like permission_classes , filter_backends , ... applies as provided to the decorator in models.py for the through model. Example \u00b6 Consider the below model: models.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from django.db import models from to_rest.decorators import restifyModel # Create your models here. @restifyModel class Student ( models . Model ): name = models . CharField ( max_length = 75 ) friends = models . ManyToManyField ( \"self\" ) def __str__ ( self ): return self . name @restifyModel class Course ( models . Model ): name = models . CharField ( max_length = 75 ) student = models . ManyToManyField ( Student ) def __str__ ( self ): return self . name Consider the following as available data: $ http -b --unsorted GET http://127.0.0.1:8000/rest/v1/edu/student/ [ { \"id\": 1, \"name\": \"John Doe\", \"course_set\": \"/rest/v1/edu/student/1/course_set/\", \"friends\": \"/rest/v1/edu/student/1/friends/\" }, { \"id\": 2, \"name\": \"Eva Doe\", \"course_set\": \"/rest/v1/edu/student/2/course_set/\", \"friends\": \"/rest/v1/edu/student/2/friends/\" }, { \"id\": 3, \"name\": \"Alice Doe\", \"course_set\": \"/rest/v1/edu/student/3/course_set/\", \"friends\": \"/rest/v1/edu/student/3/friends/\" } ] $ http -b --unsorted GET http://127.0.0.1:8000/rest/v1/edu/course/ [ { \"id\": 1, \"name\": \"CS601\", \"student\": \"/rest/v1/edu/course/1/student/\" }, { \"id\": 2, \"name\": \"CS602\", \"student\": \"/rest/v1/edu/course/2/student/\" }, { \"id\": 3, \"name\": \"CS603\", \"student\": \"/rest/v1/edu/course/3/student/\" } ] Now, to relate John Doe with CS601 and CS602 , following can be done: $ http -b --unsorted POST http://127.0.0.1:8000/rest/v1/edu/student/1/course_set/ course=1 { \"id\": 1, \"course\": 1, \"student\": 1 } $ http -b --unsorted POST http://127.0.0.1:8000/rest/v1/edu/student/1/course_set/ course=2 { \"id\": 2, \"course\": 2, \"student\": 1 } In the above example, data for through objects are provided. And the relationship between John Doe and related courses can be listed as follows: $ http -b --unsorted GET http://127.0.0.1:8000/rest/v1/edu/student/1/course_set/ [ { \"id\": 1, \"course\": 1, \"student\": 1 }, { \"id\": 2, \"course\": 2, \"student\": 1 } ] Customize nested URL behaviour \u00b6 To customize the default behaviour of the nested url(s), custom definitions for following method (decorated with the decorator rest_framework.decorators.action ) needs to be passed as custom view parameters: For Many-to-one: Name of function: to_rest.constants.ONE_TO_MANY_LIST_ACTION + relatedName signature: (self,request,pk=None, *args, **kwargs) For Many-to-many list view: Name of function: to_rest.constants.MANY_TO_MANY_LIST_ACTION + relatedName signature: (self,request,pk=None, *args,**kwargs) For Many-to-one detail view: Name of function: to_rest.constants.MANY_TO_MANY_DETAIL_ACTION + relatedName signature: self,request,childPk,pk=None,*args,**kwargs NOTE: Here pk for primary key of the parent object and childPk is primar key of the related or nested object Example \u00b6 To customize the behaviour for the example shown for Many-to-many, following can be done: view_params.py models.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from to_rest import constants from to_rest.utils import ViewParams from rest_framework.response import Response from rest_framework.decorators import action from to_rest import constants class CustomAction ( ViewParams ): def getParams (): def customaction ( self , request , pk = None , * args , ** kwargs ): if self . request . method == \"GET\" : return Response ({ 'msg' : \"Custom method working (GET)\" }) elif self . request . method == 'POST' : return Response ({ 'msg' : \"custom method working (POST)\" }) else : return Response ( status = status . HTTP_400_BAD_REQUEST ) customaction . __name__ = constants . MANY_TO_MANY_LIST_ACTION + 'course_set' customaction = action ( detail = True , methods = [ 'get' , 'post' ], url_path = 'course_set' , url_name = \"student-course_set-list\" )( customaction ) temp = dict () temp [ constants . MANY_TO_MANY_LIST_ACTION + 'course_set' ] = customaction return temp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from django.db import models from to_rest.decorators import restifyModel # Create your models here. @restifyModel ( customViewParams = 'CustomAction' ) class Student ( models . Model ): name = models . CharField ( max_length = 75 ) friends = models . ManyToManyField ( \"self\" ) def __str__ ( self ): return self . name @restifyModel class Course ( models . Model ): name = models . CharField ( max_length = 75 ) student = models . ManyToManyField ( Student ) def __str__ ( self ): return self . name Note In the above example, relatedName is course_set . While decorating the method (here at line 18): url_path must be in the form (all lower case): <relatedName> for list view <relatedName>/(?P<childPk>.+) for detail view url_name must be in the form (all lower case): <parent model name>-<relatedName>-<view type> View type can be list for list view or detail for detail view After making the avobe change, url(s) will work as follows: $ http -b GET http://127.0.0.1:8000/rest/v1/edu/student/1/course_set/ { \"msg\": \"Custom method working (GET)\" } $ http -b POST http://127.0.0.1:8000/rest/v1/edu/student/1/course_set/ { \"msg\": \"custom method working (POST)\" }","title":"Relationship"},{"location":"full_guide/relationships/#one-to-one-relationships","text":"This section shows the behaviour for one to one relationship: Consider following models: models.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from django.db import models from to_rest.decorators import restifyModel # Create your models here. @restifyModel class Student ( models . Model ): name = models . CharField ( max_length = 75 ) discipline = models . CharField ( max_length = 10 ) program = models . CharField ( max_length = 10 ) def __str__ ( self ): return \"[name= {} ; discipline= {} ; program= {} ]\" . format ( self . name , self . discipline , self . program ) @restifyModel class System ( models . Model ): name = models . CharField ( max_length = 75 ) location = models . CharField ( max_length = 20 ) student = models . OneToOneField ( Student , models . CASCADE , null = True ) def __str__ ( self ): return \"[name= {} ; location= {} ]\" . format ( self . name , self . location ) In the above models, there is a one-to-one relationship from System1 to Student1. Let us create a student object: $ http POST http://127.0.0.1:8000/rest/v1/lab/student/ name=John\\ Doe discipline=CS program=MS HTTP/1.1 201 Created Allow: GET, POST, HEAD, OPTIONS Content-Length: 73 Content-Type: application/json Cross-Origin-Opener-Policy: same-origin Date: Fri, 30 Sep 2022 09:47:29 GMT Referrer-Policy: same-origin Server: WSGIServer/0.2 CPython/3.10.6 Vary: Accept, Cookie X-Content-Type-Options: nosniff X-Frame-Options: DENY { \"discipline\": \"CS\", \"id\": 1, \"name\": \"John Doe\", \"program\": \"MS\", \"system\": null } Here, the student object has got an attribute, \"system\" which is null as this student object is not yet mapped with any system object. This attribute is a field of type OneToOneRel and not of type OneToOneField . Thus, this is a read-only field. This field will get some value when this object is mapped with a System object. Let us create a system object: $ http POST http://127.0.0.1:8000/rest/v1/lab/system/ name=Dell\\ Vostro\\ 1558 location=AB1-102 HTTP/1.1 201 Created Allow: GET, POST, HEAD, OPTIONS Content-Length: 70 Content-Type: application/json Cross-Origin-Opener-Policy: same-origin Date: Fri, 30 Sep 2022 11:27:53 GMT Referrer-Policy: same-origin Server: WSGIServer/0.2 CPython/3.10.6 Vary: Accept, Cookie X-Content-Type-Options: nosniff X-Frame-Options: DENY { \"id\": 1, \"location\": \"AB1-102\", \"name\": \"Dell Vostro 1558\", \"student\": null } Note In the model, the null flag for the OneToOneField is set as True . Not allowing null values may have restrictions on updating relations. The \"student\" attribute here is OneToOneField and is read-write. Now, this object can be used to map \"Student\" and \"System\" object as shown below: $ http PATCH http://127.0.0.1:8000/rest/v1/lab/system/1/ student=1 HTTP/1.1 200 OK Allow: GET, PUT, PATCH, DELETE, HEAD, OPTIONS Content-Length: 67 Content-Type: application/json Cross-Origin-Opener-Policy: same-origin Date: Fri, 30 Sep 2022 20:11:52 GMT Referrer-Policy: same-origin Server: WSGIServer/0.2 CPython/3.10.6 Vary: Accept, Cookie X-Content-Type-Options: nosniff X-Frame-Options: DENY { \"id\": 1, \"location\": \"AB1-102\", \"name\": \"Dell Vostro 1558\", \"student\": 1 } $ http PATCH http://127.0.0.1:8000/rest/v1/lab/student/1/ HTTP/1.1 200 OK Allow: GET, PUT, PATCH, DELETE, HEAD, OPTIONS Content-Length: 70 Content-Type: application/json Cross-Origin-Opener-Policy: same-origin Date: Fri, 30 Sep 2022 20:12:47 GMT Referrer-Policy: same-origin Server: WSGIServer/0.2 CPython/3.10.6 Vary: Accept, Cookie X-Content-Type-Options: nosniff X-Frame-Options: DENY { \"discipline\": \"CS\", \"id\": 1, \"name\": \"John Doe\", \"program\": \"MS\", \"system\": 1 } Notice that the student object now shows primary key of related \"System\" object.","title":"One-to-one relationships"},{"location":"full_guide/relationships/#many-to-one-relationships","text":"This section shows the behaviour for many to one relationship: Consider the following model: models.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from django.db import models from django.utils import timezone from to_rest.decorators import restifyModel # Create your models here. @restifyModel class Question ( models . Model ): question_text = models . CharField ( max_length = 200 ) def pub_date_default (): return timezone . now () pub_date = models . DateTimeField ( 'date published' , default = pub_date_default ) @restifyModel class Choice ( models . Model ): question = models . ForeignKey ( Question , on_delete = models . CASCADE , related_name = 'choices' ) choice_text = models . CharField ( max_length = 200 ) votes = models . IntegerField ( default = 0 ) In the above models there is a many-to-one relationship from Choice to Question . This will create a read only field called choices which will have link for the related choices object. For example: $ http GET http://127.0.0.1:8000/rest/v1/polls/question/ HTTP/1.1 200 OK Allow: GET, POST, HEAD, OPTIONS Content-Length: 136 Content-Type: application/json Cross-Origin-Opener-Policy: same-origin Date: Sun, 02 Oct 2022 09:30:42 GMT Referrer-Policy: same-origin Server: WSGIServer/0.2 CPython/3.10.6 Vary: Accept, Cookie X-Content-Type-Options: nosniff X-Frame-Options: DENY [ { \"choices\": \"/rest/v1/polls/question/1/choices/\", \"id\": 1, \"pub_date\": \"2022-10-02T09:23:28.297936Z\", \"question_text\": \"How is the traffic?\" } ] On fetching the link for choices we get all the related Choice object: $ http -b GET http://127.0.0.1:8000/rest/v1/polls/question/1/choices/ [ { \"choice_text\": \"Clear for miles...\", \"id\": 1, \"question\": 1, \"votes\": 0 }, { \"choice_text\": \"Stuck for an hour\", \"id\": 2, \"question\": 1, \"votes\": 0 } ] Note This url is only for list operations as all the other operations like create, update and delete can be done from the other side of the relationship. All the other view set attributes like permission_classes , filter_backends , ... applies as provided to the decorator in models.py. For example conside following models and view_params : view_params.py models.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from to_rest import constants from rest_framework.permissions import DjangoModelPermissions , IsAuthenticated from to_rest.utils import ViewParams from rest_framework.authentication import BasicAuthentication class DDjangoModelPermissions ( DjangoModelPermissions ): perms_map = { 'GET' : [ ' %(app_label)s .view_ %(model_name)s ' ], 'POST' : [ ' %(app_label)s .add_ %(model_name)s ' ], 'PUT' : [ ' %(app_label)s .update_ %(model_name)s ' ], 'PATCH' : [ ' %(app_label)s .update_ %(model_name)s ' ], 'DELETE' : [ ' %(app_label)s .delete_ %(model_name)s ' ] } class CustomPermission ( ViewParams ): def getParams (): temp = dict () temp [ constants . AUTHENTICATION_CLASSES ] = [ BasicAuthentication ] temp [ constants . PERMISSION_CLASSES ] = [ IsAuthenticated , DDjangoModelPermissions ] return temp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from django.db import models from django.utils import timezone from to_rest.decorators import restifyModel # Create your models here. @restifyModel ( customViewParams = 'CustomPermission' ) class Question1 ( models . Model ): question_text = models . CharField ( max_length = 200 ) def pub_date_default (): return timezone . now () pub_date = models . DateTimeField ( 'date published' , default = pub_date_default ) @restifyModel ( customViewParams = 'CustomPermission' ) class Choice1 ( models . Model ): question = models . ForeignKey ( Question1 , on_delete = models . CASCADE , related_name = 'choices' ) choice_text = models . CharField ( max_length = 200 ) votes = models . IntegerField ( default = 0 ) Now, if a user has all permissions for Question1 and not for Choice1 then the user can access the url(s) for Question1 but not the nested url for related Choice1 objects: $ http -b -a testy:test@1234 GET http://127.0.0.1:8000/rest/v1/polls/question1/ [ { \"choices\": \"/rest/v1/polls/question1/1/choices/\", \"id\": 1, \"pub_date\": \"2022-10-02T09:23:47.805702Z\", \"question_text\": \"How is the traffic?\" } ] $ http -b -a testy:test@1234 GET http://127.0.0.1:8000/rest/v1/polls/question1/1/choices/ { \"detail\": \"You do not have permission to perform this action.\" }","title":"Many-to-one relationships"},{"location":"full_guide/relationships/#many-to-many-relationships","text":"In case of many-to-many relationships, through objects for the related objects are returned from the nested url instead of the related objects as through objects have better information about the relationship. Nested url for many-to-many relationships support following operations: list (GET) create (POST) retrieve (GET) update (PUT) partial_update (PATCH) delete (DELETE) All the other view set attributes like permission_classes , filter_backends , ... applies as provided to the decorator in models.py for the through model.","title":"Many-to-many relationships"},{"location":"full_guide/relationships/#example","text":"Consider the below model: models.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from django.db import models from to_rest.decorators import restifyModel # Create your models here. @restifyModel class Student ( models . Model ): name = models . CharField ( max_length = 75 ) friends = models . ManyToManyField ( \"self\" ) def __str__ ( self ): return self . name @restifyModel class Course ( models . Model ): name = models . CharField ( max_length = 75 ) student = models . ManyToManyField ( Student ) def __str__ ( self ): return self . name Consider the following as available data: $ http -b --unsorted GET http://127.0.0.1:8000/rest/v1/edu/student/ [ { \"id\": 1, \"name\": \"John Doe\", \"course_set\": \"/rest/v1/edu/student/1/course_set/\", \"friends\": \"/rest/v1/edu/student/1/friends/\" }, { \"id\": 2, \"name\": \"Eva Doe\", \"course_set\": \"/rest/v1/edu/student/2/course_set/\", \"friends\": \"/rest/v1/edu/student/2/friends/\" }, { \"id\": 3, \"name\": \"Alice Doe\", \"course_set\": \"/rest/v1/edu/student/3/course_set/\", \"friends\": \"/rest/v1/edu/student/3/friends/\" } ] $ http -b --unsorted GET http://127.0.0.1:8000/rest/v1/edu/course/ [ { \"id\": 1, \"name\": \"CS601\", \"student\": \"/rest/v1/edu/course/1/student/\" }, { \"id\": 2, \"name\": \"CS602\", \"student\": \"/rest/v1/edu/course/2/student/\" }, { \"id\": 3, \"name\": \"CS603\", \"student\": \"/rest/v1/edu/course/3/student/\" } ] Now, to relate John Doe with CS601 and CS602 , following can be done: $ http -b --unsorted POST http://127.0.0.1:8000/rest/v1/edu/student/1/course_set/ course=1 { \"id\": 1, \"course\": 1, \"student\": 1 } $ http -b --unsorted POST http://127.0.0.1:8000/rest/v1/edu/student/1/course_set/ course=2 { \"id\": 2, \"course\": 2, \"student\": 1 } In the above example, data for through objects are provided. And the relationship between John Doe and related courses can be listed as follows: $ http -b --unsorted GET http://127.0.0.1:8000/rest/v1/edu/student/1/course_set/ [ { \"id\": 1, \"course\": 1, \"student\": 1 }, { \"id\": 2, \"course\": 2, \"student\": 1 } ]","title":"Example"},{"location":"full_guide/relationships/#customize-nested-url-behaviour","text":"To customize the default behaviour of the nested url(s), custom definitions for following method (decorated with the decorator rest_framework.decorators.action ) needs to be passed as custom view parameters: For Many-to-one: Name of function: to_rest.constants.ONE_TO_MANY_LIST_ACTION + relatedName signature: (self,request,pk=None, *args, **kwargs) For Many-to-many list view: Name of function: to_rest.constants.MANY_TO_MANY_LIST_ACTION + relatedName signature: (self,request,pk=None, *args,**kwargs) For Many-to-one detail view: Name of function: to_rest.constants.MANY_TO_MANY_DETAIL_ACTION + relatedName signature: self,request,childPk,pk=None,*args,**kwargs NOTE: Here pk for primary key of the parent object and childPk is primar key of the related or nested object","title":"Customize nested URL behaviour"},{"location":"full_guide/relationships/#example_1","text":"To customize the behaviour for the example shown for Many-to-many, following can be done: view_params.py models.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from to_rest import constants from to_rest.utils import ViewParams from rest_framework.response import Response from rest_framework.decorators import action from to_rest import constants class CustomAction ( ViewParams ): def getParams (): def customaction ( self , request , pk = None , * args , ** kwargs ): if self . request . method == \"GET\" : return Response ({ 'msg' : \"Custom method working (GET)\" }) elif self . request . method == 'POST' : return Response ({ 'msg' : \"custom method working (POST)\" }) else : return Response ( status = status . HTTP_400_BAD_REQUEST ) customaction . __name__ = constants . MANY_TO_MANY_LIST_ACTION + 'course_set' customaction = action ( detail = True , methods = [ 'get' , 'post' ], url_path = 'course_set' , url_name = \"student-course_set-list\" )( customaction ) temp = dict () temp [ constants . MANY_TO_MANY_LIST_ACTION + 'course_set' ] = customaction return temp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from django.db import models from to_rest.decorators import restifyModel # Create your models here. @restifyModel ( customViewParams = 'CustomAction' ) class Student ( models . Model ): name = models . CharField ( max_length = 75 ) friends = models . ManyToManyField ( \"self\" ) def __str__ ( self ): return self . name @restifyModel class Course ( models . Model ): name = models . CharField ( max_length = 75 ) student = models . ManyToManyField ( Student ) def __str__ ( self ): return self . name Note In the above example, relatedName is course_set . While decorating the method (here at line 18): url_path must be in the form (all lower case): <relatedName> for list view <relatedName>/(?P<childPk>.+) for detail view url_name must be in the form (all lower case): <parent model name>-<relatedName>-<view type> View type can be list for list view or detail for detail view After making the avobe change, url(s) will work as follows: $ http -b GET http://127.0.0.1:8000/rest/v1/edu/student/1/course_set/ { \"msg\": \"Custom method working (GET)\" } $ http -b POST http://127.0.0.1:8000/rest/v1/edu/student/1/course_set/ { \"msg\": \"custom method working (POST)\" }","title":"Example"}]}